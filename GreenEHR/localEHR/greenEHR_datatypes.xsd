<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified">

  <!--
   Title: greenEHR Schema Module: Datatypes

   Original Filename: greenEHR_datatypes.xsd
   Version: 0.3  
   October 24 2011

   This file is part of the greenEHR package created by
   edwin_uestc,the Center of E-Health Engineering and Technology,UESTC
   to stimulate discussion and further experimentation 
   with approaches to simplifying CDA instance creation.

   With the greenEHR files, you can

     - validate the sample instance with its green schema
     - convert the sample instance to full CDA.
	 
	 
	 问题1：
	 是否应该将每一个S2的枚举型都整成一个单独的数据类型
  -->
  <xs:simpleType name="relationshipType">
		<xs:annotation>
			<xs:documentation>不同字符表达形式的枚举:  1.A-表示字母字符A-Z a-z
													    2.N-表示数字字符0-9
														默认为GB2312
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="A"/>
			<xs:enumeration value="N"/>
		</xs:restriction>
	</xs:simpleType>  
  <xs:complexType name="S">			
		<xs:documentation>通过字符形式表达的值的类型。可包含字母字符A-Z a-z数字字符0-9等。默认为GB2312
		</xs:documentation> 
<!--    是放在属性里好呢还是放在元素里好呢
		<xs:attributeGroup ref="IdSet"/> 
		<xs:attribute name="charformat" use="required"/>
		<xs:attribute name="enumflag"minOccurs="1" maxOccurs="1" use="required"//>
		<xs:attribute name="fixedlengthflag" minOccurs="1" maxOccurs="1" use="required"/>
		<xs:attribute name="max" minOccurs="0" maxOccurs="1" />
		<xs:attribute name="min" minOccurs="0" maxOccurs="1" />
		<xs:element name="value" minOccurs="1" maxOccurs="1" use="required"/>
-->	
	<xs:sequence>
      <xs:element name="charformat" minOccurs="1" maxOccurs="1" use="required" type="xs:string"/>
      <xs:element name="enumflag" minOccurs="1" maxOccurs="1" use="required" type="xs:boolean"/>
      <xs:element name="fixedlengthflag" minOccurs="1" maxOccurs="1" use="required" type="xs:boolean"/><!--固定长度的话max=min 不固定长度的话 默认max>=min-->  
      <xs:element name="max" minOccurs="0" maxOccurs="1" type="xs:integer"/>
      <xs:element name="min" minOccurs="0" maxOccurs="1" type="xs:integer"/>
      <xs:element name="value" minOccurs="1" maxOccurs="1" use="required" type="xs:string"/><!--这里value值的类型应该是自己定义的-->
	</xs:sequence>
  </xs:complexType>
  <xs:complexType name="N">			
	<xs:documentation>通过0-9的数字形式表示的值的类型.</xs:documentation> 
	<xs:simpleContent>
		<xs:extension base="S">
			<xs:sequence>
				<xs:attribute name="charformat" minOccurs="1" maxOccurs="1" use="required" fixed="xs:string"/>
				<xs:attribute name="enumflag" minOccurs="1" maxOccurs="1" use="required" type="xs:boolean"/>
				<!--这个属性在这个类中似乎也是用不着的-->
				<xs:attribute name="fixedlengthflag" minOccurs="1" maxOccurs="1" use="required" type="xs:boolean"/>
				<xs:attribute name="max" minOccurs="0" maxOccurs="1" type="xs:integer"/>
				<xs:attribute name="min" minOccurs="0" maxOccurs="1" type="xs:integer"/>
				<xs:element name="value" minOccurs="1" maxOccurs="1" use="required" type="xs:integer"/>
			</xs:sequence>
		</xs:extension>     
	</xs:simpleContent>
  </xs:complexType>	
  <xs:complexType name="A">			
	<xs:documentation>通过A-Z a-z的字母字符形式表示的值的类型.</xs:documentation> 
	<xs:simpleContent>
		<xs:extension base="S">
			<xs:sequence>
				<xs:attribute name="charformat" minOccurs="1" maxOccurs="1" use="required" fixed="xs:string"/>
				<xs:attribute name="enumflag" minOccurs="1" maxOccurs="1" use="required" type="xs:boolean"/><!--这个属性在这个类中似乎也是用不着的-->
				<xs:attribute name="fixedlengthflag" minOccurs="1" maxOccurs="1" use="required" type="xs:boolean"/>
				<xs:attribute name="max" minOccurs="0" maxOccurs="1" type="xs:integer"/>
				<xs:attribute name="min" minOccurs="0" maxOccurs="1" type="xs:integer"/>
				<xs:element name="value" minOccurs="1" maxOccurs="1" use="required" type="xs:string">
					<xs:simpleType>
					  <xs:restriction base="xs:integer">
						<xs:pattern value="[a-z][A-Z]" maxOccurs="unbounded"/><!--这里如何让此字符重复无数多次-->
					  </xs:restriction>
					</xs:simpleType>
				</xs:element> 				
			</xs:sequence>
		</xs:extension>     
	</xs:simpleContent>
	</xs:complexType>	  
  <xs:complexType name="S1">			
	<xs:documentation>S1表示不可枚举的,且以字符a-zA-Z描述的形式表示的值的类型.</xs:documentation> 
	<xs:simpleContent>
		<xs:extension base="A">
			<xs:sequence>
				<xs:attribute name="charformat" minOccurs="1" maxOccurs="1" use="required" fixed="xs:string"/>
				<xs:attribute name="enumflag" minOccurs="1" maxOccurs="1" use="required" fixed="false"/><!--这个属性在这个类中似乎也是用不着的-->
				<xs:attribute name="fixedlengthflag" minOccurs="1" maxOccurs="1" use="required" type="xs:boolean"/>
				<xs:attribute name="max" minOccurs="0" maxOccurs="1" type="xs:integer"/>
				<xs:attribute name="min" minOccurs="0" maxOccurs="1" type="xs:integer"/>
				<xs:element name="value" minOccurs="1" maxOccurs="1" use="required" type="xs:string">
					<xs:simpleType>
					  <xs:restriction base="xs:integer">
						<xs:pattern value="[a-zA-Z]{min,max}"/><!--这里如何让此字符的长度-->
					  </xs:restriction>
					</xs:simpleType>
				</xs:element> 				
			</xs:sequence>
		</xs:extension>     
	</xs:simpleContent>
	</xs:complexType>	  	
  <xs:complexType name="S2">			
	<xs:documentation>S2表示枚举型，且列举值不超过3个的形式表示的值的类型.这里的S1其实相当于valueset的code</xs:documentation> 
	<xs:simpleContent>
		<xs:extension base="N">
			<xs:sequence>
				<xs:element name="charformat" minOccurs="1" maxOccurs="1" use="required" fixed="xs:integer"/>
				<xs:element name="enumflag" minOccurs="1" maxOccurs="1" use="required" fixed="false"/><!--这个属性在这个类中似乎也是用不着的-->
				<xs:element name="fixedlengthflag" minOccurs="1" maxOccurs="1" use="required" type="xs:boolean"/>
				<xs:element name="max" minOccurs="0" maxOccurs="1" type="xs:integer"/>
				<xs:element name="min" minOccurs="0" maxOccurs="1" type="xs:integer"/>
				<!--
						1	家里	CV03.00.102
						2	工作场所	CV03.00.102
						3	餐厅	CV03.00.102
						4	娱乐场所	CV03.00.102
						5	公共交通工具及其等候室	CV03.00.102
						9	其他	CV03.00.102	
				-->
				<xs:element name="displayname" minOccurs="1" maxOccurs="1" use="required" type="xs:string">	<!--家里-->
				<xs:element name="codesystemname" minOccurs="1" maxOccurs="1" use="required" type="xs:string">	<!--形如 被动吸烟场所类别代码表 -->	
				<xs:element name="codesystemid" minOccurs="1" maxOccurs="1" use="required" type="xs:string"><!--形如 CV03.00.102 -->						
				<xs:element name="value" minOccurs="1" maxOccurs="1" use="required" type="xs:integer"><!--形如 1 -->	
					<xs:simpleType>
					  <xs:restriction base="xs:integer">
						<xs:pattern value="[0-9]{min,max}"/><!--这里如何让此字符的长度-->
					  </xs:restriction>
					</xs:simpleType>
				</xs:element> 				
			</xs:sequence>
		</xs:extension>     
	</xs:simpleContent>
	</xs:complexType>	
  <xs:complexType name="S3">			
	<xs:documentation>S3表示代码表的形式表示的值的类型.这里的S3其实相当于codesystem的code</xs:documentation> 
	<xs:simpleContent>
		<xs:extension base="N">
			<xs:sequence>
				<xs:attribute name="charformat" minOccurs="1" maxOccurs="1" use="required" fixed="xs:integer"/>
				<xs:attribute name="enumflag"minOccurs="1" maxOccurs="1" use="required" fixed="false"//><!--这个属性在这个类中似乎也是用不着的-->
				<xs:attribute name="fixedlengthflag" minOccurs="1" maxOccurs="1" use="required" type="xs:boolean"/>
				<xs:attribute name="max" minOccurs="0" maxOccurs="1" type="xs:integer"/>
				<xs:attribute name="min" minOccurs="0" maxOccurs="1" type="xs:integer"/>
				<!--
						经济状况代码   1.贫困，在当地贫困线标准以下 2.非贫困 3.不详
				-->
				<xs:element name="displayname" minOccurs="1" maxOccurs="1" use="required" type="xs:string">	<!--贫困，在当地贫困线标准以下-->
				<xs:element name="valuesetname" minOccurs="1" maxOccurs="1" use="required" type="xs:string">	<!--形如 经济状况代码 -->	
				<xs:element name="valuesetid" minOccurs="1" maxOccurs="1" use="required" type="xs:string"><!--形如 xxxx此处标准中暂无规定 -->						
				<xs:element name="value" minOccurs="1" maxOccurs="1" use="required" type="xs:integer"><!--形如 1 -->	
					<xs:simpleType>
					  <xs:restriction base="xs:integer">
						<xs:pattern value="[0-9]{min,max}"/><!--这里如何让此字符的长度-->
					  </xs:restriction>
					</xs:simpleType>
				</xs:element> 				
			</xs:sequence>
		</xs:extension>     
	</xs:simpleContent>
	</xs:complexType>		
  <xs:complexType name="BY">
    <xs:attribute name="value" use="required" type="xs:base64Binary"/>
	<!--
		XML SCHEMA二进制数据类型用于表达二进制形式的数据。我们可使用两种二进制数据类型：		
		base64Binary (Base64 编码的二进制数据)
		hexBinary (十六进制编码的二进制数据)
	-->
  </xs:complexType>
  <xs:complexType name="D">
    <xs:attribute name="datevalue" use="required" type="xs:date"/>
	<!--
		而XML Schema里提供的date类型的默认格式是YYYY-MM-DD 扩展模式
		国标中要求采用GB/T 7408中规定的YYYYMMDD格式表示的值的类型
	-->
  </xs:complexType>  
  <xs:complexType name="T">
    <xs:attribute name="timevalue" use="required" type="xs:time"/>
	<!--
		而XML Schema里提供的time类型的默认格式是hh:mm:ss
		国标中要求采用GB/T 7408中规定的hhmmss格式表示的值的类型
	-->
  </xs:complexType>  
  <xsd:simpleType name="国标日期">
	  <xsd:restriction base="xsd:date">
		<xsd:pattern value="^([2-9]\d{3}((0[1-9]|1[012])(0[1-9]|1\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|(([2-9]\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00))0229)$" /> 
		<xsd:maxInclusive value="9999-12-31" /> 
		<xsd:minInclusive value="0001-01-01" /> 
	  </xsd:restriction>  
  </xs:simpleType>	  
<!--  
The following code performs powerful Date type validation in XSD. It validates date fields with timestamp (optional) in yyyyMMdd hh:MM:ss.ffffff format.
If your XML file contains the element ValueDate, the corresponding XSD will be this:
注意这里基本类型为string
-->
<xs:element name="ValueDate" type="dateType"/>

<xs:simpleType name= "timestampType">
  <xs:restriction base = "xs:string">
   <xs:pattern value='[1-9][0-9][0-9][0-9](([0][1|3|5|7|8])([0][1-9]|[1-2][0-9]|[3][0-1])|([0][4|6|9])
([0][1-9]|[1-2][0-9]|[3][0])|([0][2])([0][1-9]|[1-2][0-9])|([1][0|2])([0][1-9]|[1-2][0-9]|[3][0-1])|([1]
[1])([0][1-9]|[1-2][0-9]|[3][0]))([ ]([2][1-4]|[0][0-9]|[1][0-9])[:]([0-5][0-9]|[6][0])[:]([0-5][0-9]|[6]
[0])[.][0-9]{6})*'/>
  </xs:restriction>
</xs:simpleType>
</code></pre>
<!--
扩展格式的时间 日期的定义
date			YYYY-MM-DD
time			hh:mm:ss[.nnnnnnn]
datetime2		YYYY-MM-DDThh:mm:ss[.nnnnnnn]
datetimeoffset	YYYY-MM-DDThh:mm:ss[.nnnnnnn] [+|-]hh:mm
<xsd:simpleType name="datetime">
  <xsd:restriction base="xsd:dateTime">
....<xsd:pattern value="((000[1-9])|(00[1-9][0-9])|(0[1-9][0-....9]{2})|([1-9][0-9]{3}))-((0[1-9])|(1[012]))-((0[1-9])|([12][0-....9])|(3[01]))T(([01][0-9])|(2[0-3]))(:[0-5][0-9]){2}(\.[0-....9]{2}[037])?" /> 
    <xsd:maxInclusive value="9999-12-31T23:59:59.997" /> 
    <xsd:minInclusive value="1753-01-01T00:00:00.000" /> 
  </xsd:restriction>
</xsd:simpleType>
<xsd:simpleType name="smalldatetime">
  <xsd:restriction base="xsd:dateTime">
    <xsd:pattern value="((000[1-9])|(00[1-9][0-9])|(0[1-9][0-9]{2})|([1-9][0-9]{3}))-((0[1-9])|(1[012]))-((0[1-9])|([12][0-9])|(3[01]))T(([01][0-9])|(2[0-3]))(:[0-5][0-9])(:00)" /> 
    <xsd:maxInclusive value="2079-06-06T23:59:00" /> 
    <xsd:minInclusive value="1900-01-01T00:00:00" /> 
  </xsd:restriction>
</xsd:simpleType>
<xsd:simpleType name="date">
  <xsd:restriction base="xsd:date">
    <xsd:pattern value="((000[1-9])|(00[1-9][0-9])|(0[1-9][0-9]{2})|([1-9][0-9]{3}))-((0[1-9])|(1[012]))-((0[1-9])|([12][0-9])|(3[01]))" /> 
    <xsd:maxInclusive value="9999-12-31" /> 
    <xsd:minInclusive value="0001-01-01" /> 
  </xsd:restriction>
</xsd:simpleType>
xsd:simpleType name="time">
  <xsd:restriction base="xsd:time">
    <xsd:pattern value="(([01][0-9])|(2[0-3]))(:[0-5][0-9]){2}(\.[0-9]+)?" /> 
    <xsd:annotation>
    <xsd:minInclusive value="00:00:00" /> 
    </xsd:annotation>
  </xsd:restriction>
</xsd:simpleType>
<xsd:simpleType name="datetime2">
  <xsd:restriction base="xsd:dateTime">
    <xsd:pattern value="((000[1-9])|(00[1-9][0-9])|(0[1-9][0-9]{2})|([1-9][0-9]{3}))-((0[1-9])|(1[012]))-((0[1-9])|([12][0-9])|(3[01]))T(([01][0-9])|(2[0-3]))(:[0-5][0-9]){2}(\.[0-9]+)?" /> 
<xsd:annotation>
  <xsd:minInclusive value="0001-01-01T00:00:00" />
</xsd:annotation>
  </xsd:restriction>
</xsd:simpleType>
<xsd:simpleType name="DATETIMEOFFSET">
  <xsd:restriction base="xsd:dateTime" />
     <xsd:pattern value="((000[1-9])|(00[1-9][0-9])|(0[1-9][0-9]{2})|([1-9][0-9]{3}))-((0[1-9])|(1[012]))-((0[1-9])|([12][0-9])|(3[01]))T(([01][0-9])|(2[0-3]))(:[0-5][0-9]){2}(\.[0-9]+)?(([\+|\-]((0[0-9])|(1[0-2]))(:[0-5][0-9]))|(\+13(:[0-5][0-9])(:[0-5][0-9]))|\+14:00|Z)"(([\+|\-]((((0[0-9])|(1[0-3]))(:[0-5][0-9]))|14:00))|Z)" /> 
    <xsd:minInclusive value="0001-01-01T00:00:00Z" /> 
  </xsd:restriction>
</xsd:simpleType>
-->
<!--
日期时间验证的正则表达式
http://dev.mjxy.cn/a-Common-regular-expressions.aspx

正则表达式	
(?n:^(?=\d)((?<day>31(?!(.0?[2469]|11))|30(?!.0?2)|29(?(.0?2)(?=.{3,4}(1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|(16|[2468][048]|[3579][26])00))|0?[1-9]|1\d|2[0-8])(?<sep>[/.-])(?<month>0?[1-9]|1[012])\2(?<year>(1[6-9]|[2-9]\d)\d{2})(?:(?=\x20\d)\x20|$))?(?<time>((0?[1-9]|1[012])(:[0-5]\d){0,2}(?i:\ [AP]M))|([01]\d|2[0-3])(:[0-5]\d){1,2})?$)
匹配	
31/12/2003 | 29/2/2004 4:50 PM | 23:59:59
不匹配	
12/31/2003 | 29/2/2003 | 4:00

正则表达式	
^(?:(?:31(\/|-|\.)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/|-|\.)(?:0?[1,3-9]|1[0-2])\2))(?:(?:1[6-9]|[2-9]\d)?\d{2})$|^(?:29(\/|-|\.)0?2\3(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\d|2[0-8])(\/|-|\.)(?:(?:0?[1-9])|(?:1[0-2]))\4(?:(?:1[6-9]|[2-9]\d)?\d{2})$
匹配	
29/02/1972 | 5-9-98 | 10-11-2002
不匹配	
29/02/2003 | 12/13/2002 | 1-1-1500

正则表达式	
^(?:(((Jan(uary)?|Ma(r(ch)?|y)|Jul(y)?|Aug(ust)?|Oct(ober)?|Dec(ember)?)\ 31)|((Jan(uary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sept|Nov|Dec)(ember)?)\ (0?[1-9]|([12]\d)|30))|(Feb(ruary)?\ (0?[1-9]|1\d|2[0-8]|(29(?=,\ ((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))))\,\ ((1[6-9]|[2-9]\d)\d{2}))
匹配	
Jan 1, 2003 | February 29, 2004 | November 02, 3202
不匹配	
Feb 29, 2003 | Apr 31, 1978 | jan 33,3333

正则表达式	
^(([0-1]?[0-9])|([2][0-3])):([0-5]?[0-9])(:([0-5]?[0-9]))?$
匹配	
12:15 | 10:26:59 | 22:01:15
不匹配	
24:10:25 | 13:2:60

正则表达式	
(?=\d)^(?:(?!(?:10\D(?:0?[5-9]|1[0-4])\D(?:1582))|(?:0?9\D(?:0?[3-9]|1[0-3])\D(?:1752)))((?:0?[13578]|1[02])|(?:0?[469]|11)(?!\/31)(?!-31)(?!\.31)|(?:0?2(?=.?(?:(?:29.(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\d\d)(?:[02468][048]|[13579][26])(?!\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\x20BC))))))|(?:0?2(?=.(?:(?:\d\D)|(?:[01]\d)|(?:2[0-8])))))([-.\/])(0?[1-9]|[12]\d|3[01])\2(?!0000)((?=(?:00(?:4[0-5]|[0-3]?\d)\x20BC)|(?:\d{4}(?!\x20BC)))\d{4}(?:\x20BC)?)(?:$|(?=\x20\d)\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\d){0,2}(?:\x20[aApP][mM]))|(?:[01]\d|2[0-3])(?::[0-5]\d){1,2})?$
匹配	
11/24/0004 11:59 PM | 2.29.2008 | 02:50:10
不匹配	
12/33/1020 | 2/29/2005 | 13:00 AM

正则表达式	
^([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0]?[1-9]|[1][0-2])[./-]([0-9]{4}|[0-9]{2})$
匹配	
10/03/1979 | 1-1-02 | 01.1.2003
不匹配	
10/03/197 | 09--02--2004 | 01 02 03

正则表达式	
^((0?[13578]|10|12)(-|\/)(([1-9])|(0[1-9])|([12])([0-9]?)|(3[01]?))(-|\/)((19)([2-9])(\d{1})|(20)([01])(\d{1})|([8901])(\d{1}))|(0?[2469]|11)(-|\/)(([1-9])|(0[1-9])|([12])([0-9]?)|(3[0]?))(-|\/)((19)([2-9])(\d{1})|(20)([01])(\d{1})|([8901])(\d{1})))$
匹配	
1/2/03 | 02/30/1999 | 3/04/00
不匹配	
3/4/2020 | 3/4/1919 | 4/31/2000

正则表达式	
^([2-9]\d{3}((0[1-9]|1[012])(0[1-9]|1\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|(([2-9]\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00))0229)$
匹配	 20000101 | 20051231 | 20040229
不匹配	 19990101 | 20053112 | 20050229
正则表达式	
^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][aApP][mM]){1}$
匹配	 08:00AM | 10:00am | 7:00pm
不匹配	 13:00pm | 12:65am
正则表达式	
^(([1-9])|(0[1-9])|(1[0-2]))\/(([0-9])|([0-2][0-9])|(3[0-1]))\/(([0-9][0-9])|([1-2][0,9][0-9][0-9]))$
匹配	 01/01/2001 | 1/1/1999 | 10/20/2080
不匹配	 13/01/2001 | 1/1/1800 | 10/32/2080
正则表达式	
^\d{1,2}\/\d{1,2}\/\d{4}$
匹配	 4/1/2001 | 12/12/2001 | 55/5/3434
不匹配	 1/1/01 | 12 Jan 01 | 1-1-2001
正则表达式	
(\d{2}|\d{4})(?:\-)?([0]{1}\d{1}|[1]{1}[0-2]{1})(?:\-)?([0-2]{1}\d{1}|[3]{1}[0-1]{1})(?:\s)?([0-1]{1}\d{1}|[2]{1}[0-3]{1})(?::)?([0-5]{1}\d{1})(?::)?([0-5]{1}\d{1})
匹配	 00-00-00 00:00:00 | 0000-00-00 00:00:00 | 09-05-22 08:16:00 | 1970-00-00 00:00:00 | 20090522081600
不匹配	 2009-13:01 00:00:00 | 2009-12-32 00:00:00 | 2002-12-31 24:00:00 | 2002-12-31 23:60:00 | 02-12-31 23:00:60
正则表达式	
^(?=\d)(?:(?!(?:1582(?:\.|-|\/)10(?:\.|-|\/)(?:0?[5-9]|1[0-4]))|(?:1752(?:\.|-|\/)0?9(?:\.|-|\/)(?:0?[3-9]|1[0-3])))(?=(?:(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:\d\d)(?:[02468][048]|[13579][26]))\D0?2\D29)|(?:\d{4}\D(?!(?:0?[2469]|11)\D31)(?!0?2(?:\.|-|\/)(?:29|30))))(\d{4})([-\/.])(0?\d|1[012])\2((?!00)[012]?\d|3[01])(?:$|(?=\x20\d)\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\d){0,2}(?:\x20[aApP][mM]))|(?:[01]\d|2[0-3])(?::[0-5]\d){1,2})?$
匹配	 0008-02-29 | 2:34:59 PM | 9999/12/31 11:59 PM
不匹配	 04/04/04 | 1:00 | 1999/1/32
正则表达式	
^(([1-9]{1})|([0-1][0-9])|([1-2][0-3])):([0-5][0-9])$
匹配	 00:00 | 23:59 | 10:10
不匹配	 24:00 | 00:60 | 25:61
正则表达式	
^[0-9]{4}-(((0[13578]|(10|12))-(0[1-9]|[1-2][0-9]|3[0-1]))|(02-(0[1-9]|[1-2][0-9]))|((0[469]|11)-(0[1-9]|[1-2][0-9]|30)))$
匹配	 2004-04-30 | 2004-02-29
不匹配	 2004-04-31 | 2004-02-30

-->	
</xs:schema>
